#include "../include/model.hpp"
#include "../include/utils.hpp"

#include <fmt/format.h>
#include <clara.hpp>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <math.h>

int sim_test(int argc, char* argv[]);
int sim_anim(int argc, char* argv[]);
int sim_record(int argc, char* argv[]);
int sim_visualize(int argc, char* argv[]);
int sim_all(int argc, char* argv[]);
int sim_all_threaded(int argc, char* argv[]);
int sim_generate(int argc, char* argv[]);
int sim_generate_threaded(int argc, char* argv[]);
int sim_singleflock(int argc, char* argv[]);


int main(int argc, char* argv[])
{
	if (!(argc>1)) {
		fmt::print(stderr,"{}: must be at least one program argument\n",argv[0]);
		return EXIT_FAILURE;
	}

	fmt::print("\nNoise : UNIFORM (WRAPPED)\n\n");

	bool showHelp = false;
	std::string command;
	using namespace clara::detail;
	auto cli = Help(showHelp)
		| Arg(command, "submodule")("Which submodule to run:\ntest - Ensure program works\n"
			"anim - Animate model\ngenerate - Run model and generate a state file\n"
			"analyse - Run state file from generate and calculate metrics\n"
			"generate/analyse_threaded - Threaded model versions (Only SVM currently)\n"
			"record - Run simulation and record every frame\n"
			"visualise - Visualise data generated by record\n"
			"singleflock - (Experimental) Perform simulation and analysis based on connected flocks").required();
	auto result = cli.parse(Args(2, argv)); // Just read first two args
	if (!result) {
		fmt::print("Error in command line: {}\n", result.errorMessage());
		return EXIT_FAILURE;
	}
	if (showHelp) {
		std::cerr << cli << std::endl;
		return EXIT_SUCCESS;
	}
	int retCode;
	{
		ScopeTimer timer("Vicsek");
		int argc_1 = argc - 1;	char** argv_1 = argv + 1; // Clara expects just one ignored argument, so move forward by one
		if (command == "test") retCode = sim_test(argc_1, argv_1);
		else if (command == "anim") retCode = sim_anim(argc_1, argv_1);
		else if (command == "visualize") retCode = sim_visualize(argc_1, argv_1);
		else if (command == "record") retCode = sim_record(argc_1, argv_1);
		else if (command == "analyse") retCode = sim_all(argc_1, argv_1);
		else if (command == "analyse_threaded") retCode = sim_all_threaded(argc_1, argv_1);
		else if (command == "generate") retCode = sim_generate(argc_1, argv_1);
		else if (command == "generate_threaded") retCode = sim_generate_threaded(argc_1, argv_1);
		else if (command == "singleflock") retCode = sim_singleflock(argc_1, argv_1);
		else
		{
			fmt::print(stderr, "{}: unknown submodule '{}'\n", argv[0], argv[1]);
			return EXIT_FAILURE;
		}
	}
	return retCode;
}
